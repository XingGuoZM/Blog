
前端工程化是一个很大的议题，基本上工程化体系是离不开webpack和js模块。首先先从模块说起，面试的时候免不了会被问到几个模块相关的问题。例如
1. 说一说模块化的好处？前端模块化解决了哪些问题？
2. 说一说es module和commonjs module的区别？commonjs require函数的工作原理？
3. module.export、export 与 export defalut 有什么区别？
...
...
...

## js模块介绍
模块化就是将一个大文件拆分成相互依赖的小文件，再通过打包工具进行统一的拼装和加载。有人会问了模块化的好处是什么，或者说为什么要做模块化？其实这样做的好处可以从两个角度分析

1. 前端开发人员可以遵循统一标准规范，多人协作同时进行系统开发，加快开发速度
2. 代码稳定，模块间相互隔离，相互独立，互不影响。解决命名冲突等。
3. 代码可读性：代码被分割成细小的整体，可读性变强。
4. 可复用性：模块间相互独立，互不影响，可复用性高。
5. 可维护性：依赖关系明确清晰，易于维护。

js的模块标准有两种 commonjs module和es6之后开始支持的es module。node应用采用的commonjs module规范，web应用一般采用es module规范。

### commonjs module和es module
commonjs module简称cjs,es module简称mjs,下同。

cjs
- require函数，用于导入
- module.exports变量，用于导出，也可以直接exports
例如
```js
//add.js
function add(a,b){
  return a+b;
}

module.exports={add};

//index.js
const {add} =require('./add');
add(1,2);
```

模块的导入导出需要注意的问题
- exports不能直接对其赋值，例如下代码是不会正常导出的
```js
//add.js
function add (a,b){
  return a+b
};
exports={add};
```
- 在同一个文件中，exports和module.exports尽量不要同时使用，例如下代码
```js
exports.add=function(a,b){
  return a+b;
}
module.exports={
  name:'jack'
}
```
- module.exports或者exports尽量放在文件的末尾,可以提高代码的可读性
- require的模块如果是第一次被加载，首先会执行该模块然后导出内容。如果不是第一次被加载，这时该模块代码不会再次执行，而是直接导出上次执行后的结果。

mjs
- import命令用于导入
- export命令用于导出
例如
```js
//sum.js
import 
```
这两个关键字浏览器都不支持

cjs的加载机制是输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值

require函数是CommonJS规范之中，用来加载其他模块的函数。它其实不是一个全局函数，而是指向当前模块的module.require函数，而后者又调用Node的内部命令Module._load。

cjs是在运行时才确定引入, 然后执行这个模块, 相当于是调用一个函数, 返回一个对象.
mjs是语言层面的, 导入导出是声明式的代码集合. 声明式的意思就是说, 直接利用关键字声明说我要导入/导出一个模块啦, 而不是粗鄙(节目效果)地将一个对象赋值给一个变量

**require函数的加载规则，根据参数的不同格式，require命令去不同路径寻找模块文件**
1. 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。
2. 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件
3. 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）
4. 如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require('example-module/path/to/file')，则将先找到example-module的位置，然后再以它为参数，找到后续路径
5. 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析
6. 如果想得到require命令加载的确切文件名，使用require.resolve()方法

**require函数缓存**
当第一次加载某个模块时，node会缓存该模块，以后再加载该模块时，就直接从缓存中取出该模块的module.exports属性

**cjs和mjs有何区别**
cjs在运行时解析模块依赖，mjs在编译时解析模块依赖

**如何处理模块的循环加载？**
CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行，CommonJS的做法是，一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。require函数第一次导入时会自动缓存结果，第二次再导入模块时会直接给到结果。
import不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值

```js
//add.js
function add (a,b){
  return a+b
};
exports={add};

// index.js
const { add } = require('./sum');
add(1, 2);
```
上面的代码运行之后会报错，会报“add is not a function”,exports 不能被赋值对象。要改正很简单，直接使用module.exports,或者使用exports.add=add。这两种都可以解决报错问题。

```js
//add.js
function add (a,b){
  return a+b
};
module.exports={add};

// index.js
const { add } = require('./sum');
add(1, 2);
```

### 参考
- [CommonJS 规范](http://wiki.commonjs.org/wiki/CommonJS)