
前端工程化是一个很大的议题，基本上工程化体系是离不开webpack和js模块。首先先从模块说起，面试的时候免不了会被问到几个模块相关的问题。例如
1. 说一说模块化的好处？前端模块化解决了哪些问题？
2. 说一说es module和commonjs module的区别？commonjs require函数的工作原理？
3. module.export、export 与 export defalut 有什么区别？
...
...
...

## js模块介绍
模块化就是将一个大文件拆分成相互依赖的小文件，再通过打包工具进行统一的拼装和加载。有人会问了模块化的好处是什么，或者说为什么要做模块化？其实这样做的好处可以从两个角度分析

1. 前端开发人员可以遵循统一标准规范，多人协作同时进行系统开发，加快开发速度
2. 代码稳定，模块间相互隔离，相互独立，互不影响。解决命名冲突等。
3. 代码可读性：代码被分割成细小的整体，可读性变强。
4. 可复用性：模块间相互独立，互不影响，可复用性高。
5. 可维护性：依赖关系明确清晰，易于维护。

js的模块标准有两种 commonjs module和es6之后开始支持的es module。node应用采用的commonjs module规范，web应用一般采用es module规范。

### commonjs module和es module
commonjs module简称cjs,es module简称mjs,下同。

cjs
- require函数，用于导入
- module.exports变量，用于导出
这两个关键字浏览器都不支持

cjs的加载机制是输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值

require函数是CommonJS规范之中，用来加载其他模块的函数。它其实不是一个全局函数，而是指向当前模块的module.require函数，而后者又调用Node的内部命令Module._load。

cjs是在运行时才确定引入, 然后执行这个模块, 相当于是调用一个函数, 返回一个对象.
mjs是语言层面的, 导入导出是声明式的代码集合. 声明式的意思就是说, 直接利用关键字声明说我要导入/导出一个模块啦, 而不是粗鄙(节目效果)地将一个对象赋值给一个变量

**require函数的加载规则，根据参数的不同格式，require命令去不同路径寻找模块文件**
1. 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。
2. 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件
3. 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）
4. 如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require('example-module/path/to/file')，则将先找到example-module的位置，然后再以它为参数，找到后续路径
5. 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析
6. 如果想得到require命令加载的确切文件名，使用require.resolve()方法

**cjs和mjs有何区别**
cjs在运行时解析模块依赖，mjs在编译时解析模块依赖

**如何处理模块的循环加载？**


### 参考
- [CommonJS 规范](http://wiki.commonjs.org/wiki/CommonJS)